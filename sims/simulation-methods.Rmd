---
title: "Forwards landscape genomics simulations."
date: "`r date()`"
author: "Peter Ralph"
---


```{r doc_setup, include=FALSE}
fig.dim <- 5
knitr::opts_chunk$set(fig.width=2*fig.dim,fig.height=fig.dim,fig.align='center')
library(Matrix)
library(raster)
devtools::load_all("../landsim")
```

Here's a simple layer we'll work with.
Note that units are in meters.
```{r setup_layer}
habitat <- raster(xmn=-1000, xmx=1000, ymn=-1000, ymx=1000, 
      resolution=100,
      crs="+proj=utm +zone=11 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs")
values(habitat) <- sample( 100*c(1,2,5,NA), length(habitat), replace=TRUE )
plot(habitat)
```


Migration operations
====================

We can do migration in two ways:
either by matrix multiplication,
or by doing smoothing operations directly on the layers.


Matrices
--------

The easiest migration matrix to create is a nearest-neighbor migration:
```{r nn_mig}
nn.mig <- layer_adjacency(habitat)
image(nn.mig)
```

Alternatively, consider a Gaussian kernel:
```{r gaus_mig}
gauss.mig <- kernel_adjacency(habitat,sigma=100,radius=500,fun="gaussian")
image(gauss.mig)
```

Or, a two-dimensional, symmetric Cauchy kernel:
```{r cauchy_mig}
cauchy.mig <- kernel_adjacency(habitat,sigma=100,radius=800,fun="cauchy")
image(cauchy.mig)
```


Smoothing operations
--------------------

The `raster` package does smoothing operations directly, with `raster::focal`.
For instance, we can assign random values to the non-NA values in the layer
and then smooth them with a Gaussian kernel:
```{r gauss_smooth}
N <- habitat
values(N)[!is.na(values(N))] <- rpois(sum(!is.na(values(N))),values(habitat)[!is.na(values(N))])
plot(N)
gauss.N <- kernel_migrate(N,radius=500,sigma=100)
plot(gauss.N)
```


A simulation step
=================

```{r plot_setup}
# plotting function for typical layers below
this.plot <- function (x,nr=1,zlim=c(0,max(values(x),na.rm=TRUE)),...) {
    plot(x,nr=nr,zlim=zlim,...)
}
```

Beginning with a population:
```{r init_pop}
N <- rpois_raster( brick( habitat, habitat, habitat )/3 )
genotypes <- names(N) <- c("aa","aA","AA")
this.plot(N)
```

Here are the population parameters.
To maintain population densities,
we'll make the germination rate depend on the local population density.
Concretely, let's use something motivated by the Beverton-Holt model,
which without age structure has $n' = r_0/(1/n+1/M)$,
and carrying capacity $(r_0-1)M$:
if $f(x)$ is the nearby population density (possibly smoothed somehow),
then the germination rate is $r_0/(1+f(x)/M(x))$.
```{r init_params}
# probability of seeding in a given year
prob.seed <- 0.2
# pollen dispersal kernel
pollen.kernel <- function (x) { exp(-sqrt(x)) }
pollen.sigma <- 100
max.pollen.dist <- 1000
# seed dispersal kernel
seed.kernel <- "gaussian"
seed.sigma <- 20
max.seed.dist <- 400
# number of seeds per individual
seed.fecundity <- 200
# genotype offspring tensor: 
#  [i,j,k] is the probability that genotypes i and j combine to make offspring genotype k
mating.tensor <- array( c(
        # aa offspring
        1,   1/2,   0, # aa
        1/2, 1/4,   0, # aA
        0,     0,   0, # AA
        # aA offspring
        0,   1/2,   1, # aa
        1/2, 1/2, 1/2, # aA
        1,   1/2,   0, # AA
        # AA offspring
        0,     0,   0, # aa
        0,   1/4, 1/2, # aA
        0,   1/2,   1  # AA
        ), dim=c(3,3,3) )
dimnames(mating.tensor) <- list( genotypes, genotypes, genotypes )
# raw germination rate
prob.germination <- 0.01
# competition kernel for germination
competition.kernel <- "gaussian"
competition.sigma <- 100
max.competition.dist <- 300
# sort of carrying capacity
carrying.capacity <- habitat
# probability of survival
prob.survival <- 0.9
```


1. **Sample the number of seed-producing individuals:**

```{r seeds}
M <- rbinom_raster(N,prob.seed)
this.plot(M)
```

2. **Find the mean pollen flux:**

```{r pollen}
P <- kernel_migrate(N,fun=pollen.kernel,sigma=pollen.sigma,radius=max.pollen.dist)
this.plot(P)
```

3. **Find the mean seed production field:**

```{r mean_seed}
S <- seed_production(seeders=M,pollen=P,mating=mating.tensor,
                     fecundity=seed.fecundity)
this.plot(S)
```

4. **Disperse seeds:**

```{r disperse_seeds}
SD <- kernel_migrate(S,fun=seed.kernel,sigma=seed.sigma,radius=max.seed.dist,
                     normalize=TRUE)
this.plot(SD)
```
5. **Find competition kernel:**
    according to $r_0/(1+f(x)/M(x))$:

```{r get_competition}
K <- kernel_migrate(sum(N),fun=competition.kernel,sigma=competition.sigma,
                    radius=max.competition.dist,normalize=TRUE)
K <- prob.germination/(1+K/carrying.capacity)
this.plot(K)
```

6. **Sample new individuals:**

```{r new_inds}
G <- rpois_raster(SD*K)
this.plot(G)
```

7. **Kill off old individuals and add in new ones:**

```{r next_gen}
NN <- rbinom_raster(N,prob.survival) + G
this.plot(NN)
```


Abstracting the simulation step
===============================

Now let's wrap those parameters up into an object.
One structure we use several times
is the setup for smoothing (with `kernel_migrate`);
for this we need to know:

Class **smoother**:

`kernel`

: function that gives weights for neighboring cells as a function of Euclidean distance

`sigma`

: scaling factor on distance before being passed to `kernel`

`radius`

: maximum range of the smoother

`normalize`

: normalization factor applied to the smoother


Several of the base demographic parameters we might want to specify
(as a fixed number or a layer),
or compute (as a function of the current population state).
Such **parameters** can be either something numeric
or else a function that is applied to `N` to get the result.

Then, to do a single generation we need to know:

Class **demography**:

`prob.seed`

: `parameter` object for  probability of seeding per individual per year

`fecundity`

: `parameter` object for mean number of seeds per seeding individual per year

`prob.germination`

: `parameter` object for probability of germination

`prob.survival`

: `parameter` object for probability of survival of already existing individuals

`pollen.smoother`

: `smoother` object for pollen dispersal (normalized to total pollen production)

`seed.smoother`

: `smoother` object for seed dispersal (normalized to 1)

`genotypes`

: vector of names of the genotypes represented by the layers

`mating`

: genotype x genotype x genotype tensor, with entry
    `[i,j,k]` the probability that genotypes `i` and `j` combine to make offspring genotype `k`
